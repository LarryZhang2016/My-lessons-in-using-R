[
["index.html", "The lessons I learned in using R Preface", " The lessons I learned in using R Lingyun Zhang 2018-3-23 Preface To be written. “Failures teach success.” "],
["small-lessons.html", "1 Small lessons 1.1 Always use na.rm = TRUE 1.2 Always use seq_along 1.3 Always use drop = FALSE 1.4 Always use dir.create() 1.5 Leap year problem 1.6 NA may cause troubles 1.7 using tidyr::spread()", " 1 Small lessons 1.1 Always use na.rm = TRUE The following code is correct in terms of syntax, but it does not give the result that we expect. x &lt;- c(1:3, NA, 4) (y &lt;- sum(x)) ## [1] NA Instead, we should use x &lt;- c(1:3, NA, 4) (y &lt;- sum(x, na.rm = TRUE)) ## [1] 10 1.2 Always use seq_along Sometime ago, I often write in my program something like s &lt;- 0 for(i in 1:length(x)) s &lt;- s + 1 This piece of code may fail because the length of x may be 0. The safer and right way is to use seq_along. So, the code should be changed to s &lt;- 0 for(i in seq_along(x)) s &lt;- s + 1 1.3 Always use drop = FALSE Let’s look at the following example: x &lt;- diag(3) y1 &lt;- x[-1, ] y2 &lt;- x[-c(1, 2), ] y3 &lt;- x[-c(1, 2, 3), ] (is.matrix(y1)) ## [1] TRUE (is.matrix(y2)) ## [1] FALSE (is.matrix(y3)) ## [1] TRUE This is interesting, isn’t? The above example shows a tiny bit of inconsistency in R; this inconsistency is dangerous for programmers. To remove the inconsistency, we should change the code to x &lt;- diag(3) y1 &lt;- x[-1, , drop = FALSE] y2 &lt;- x[-c(1, 2), , drop = FALSE] y3 &lt;- x[-c(1, 2, 3), , drop = FALSE] (is.matrix(y1)) ## [1] TRUE (is.matrix(y2)) ## [1] TRUE (is.matrix(y3)) ## [1] TRUE (y3) ## [,1] [,2] [,3] Note that y3 is a matrix of 0 rows and 3 columns. y3 is not a real matrix in the mathematical sense but it is a legal one in R. 1.4 Always use dir.create() I have the habit of creating folders by hand, but for writing programs that will be used by other people we should always do the following: if(!dir.exists(&quot;./Folder-name&quot;)) dir.create(&quot;./Folder-name&quot;) 1.5 Leap year problem Suppose we want to get data from today back to three years ago from a database; we may write code like the following: library(lubridate) (query_start &lt;- today() - years(3)) ## [1] &quot;2015-11-24&quot; The code are OK most of time, but we will be in trouble if today is February 29, 2016. Let’s see following code: (query_start &lt;- as.Date(&quot;2016-02-29&quot;) - years(3)) ## [1] NA We got an NA; of course this is not what we wanted! We can write safer code as follows: library(lubridate) m_d &lt;- substring(ymd(today()), 6, 10) if(m_d == &quot;02-29&quot;) { query_start &lt;- today() + days(1) - years(3) - days(1) } else { query_start &lt;- today() - years(3) } (query_start) ## [1] &quot;2015-11-24&quot; 1.6 NA may cause troubles We must be very cautious when we are dealing with NA’s. The following code looked OK, but it does not give what we expect. library(dplyr) a_df &lt;- data.frame(x = c(letters[1:5], rep(NA, 3))) b_df &lt;- a_df %&gt;% filter(x != &quot;c&quot;) The right code should be library(dplyr) a_df &lt;- data.frame(x = c(letters[1:5], rep(NA, 3))) b_df &lt;- a_df %&gt;% filter(x != &quot;c&quot; | is.na(x)) because we want to keep the rows where x is NA. 1.7 using tidyr::spread() I saw an example from https://www.r-bloggers.com/workaround-for-tidyrspread-with-duplicate-row-identifiers/, and I created a new example by tweaking the original one. library(tidyr) library(dplyr) long_table &lt;- data.frame(age = sample(15:29, 5), gender = sample(c(&quot;m&quot;, &quot;f&quot;), 5, replace = TRUE)) (long_table) ## age gender ## 1 21 f ## 2 25 f ## 3 28 m ## 4 20 f ## 5 23 m ## this does not work # wide_table &lt;- # long_table %&gt;% # spread(key = gender, value = age) ## this works wide_table &lt;- long_table %&gt;% mutate(n = row_number()) %&gt;% spread(key = gender, value = age) %&gt;% select(-n) %&gt;% arrange(f) (wide_table) ## f m ## 1 20 NA ## 2 21 NA ## 3 25 NA ## 4 NA 28 ## 5 NA 23 "],
["big-lessons.html", "2 Big lessons 2.1 Counting is not that easy 2.2 Joining tables, be careful!", " 2 Big lessons 2.1 Counting is not that easy Finding number of rows under some constraints and then getting some a ratio is a common practice for an analyst who is doing official statistics. But sometimes counting is not that easy when a record is not the same as a response. An example is that people are allowed to make multiple choices. We use the following fake data to tell two stories. library(readr) the_url &lt;- &quot;https://raw.githubusercontent.com/LarryZhang2016/Data/master/fake_data_4_counting_example.csv&quot; fake_data &lt;- read_csv(the_url) print.data.frame(fake_data) ## ID Q_NO answers ## 1 1 1 C ## 2 1 2 B ## 3 1 2 A ## 4 1 3 C ## 5 1 4 A ## 6 1 4 C ## 7 2 1 A ## 8 2 1 B ## 9 2 2 C ## 10 2 2 A ## 11 2 2 B ## 12 2 3 C ## 13 2 4 A ## 14 2 4 B ## 15 2 4 C ## 16 3 1 C ## 17 3 1 A ## 18 3 2 A ## 19 3 3 A ## 20 3 3 B ## 21 3 4 A ## 22 4 1 A ## 23 4 1 B ## 24 4 1 C ## 25 4 2 C ## 26 4 2 B ## 27 4 2 A ## 28 4 3 A ## 29 4 3 B ## 30 4 4 B ## 31 4 4 C ## 32 4 4 A ## 33 5 1 A ## 34 5 2 A ## 35 5 3 A ## 36 5 3 B ## 37 5 4 B ## 38 5 4 C ## 39 5 4 A Story 1: Find the number of respondents. The code below is wrong! library(dplyr) no_of_respondents &lt;- fake_data %&gt;% summarise(n = n()) print.data.frame(no_of_respondents) ## n ## 1 39 Here we should use n_distinct(), and the correct code is: library(dplyr) no_of_respondents &lt;- fake_data %&gt;% summarise(n = n_distinct(ID)) print.data.frame(no_of_respondents) ## n ## 1 5 Story 2: Tally the data with one dimension be Question-Number and the other dimension be Answers, and then create another table, which shows the proportions of people made the choice. no_of_people_choose_A_4_Q1 &lt;- fake_data %&gt;% group_by(Q_NO, answers) %&gt;% tally() %&gt;% tidyr::spread(key = answers, value = n) print.data.frame(no_of_people_choose_A_4_Q1) ## Q_NO A B C ## 1 1 4 2 3 ## 2 2 5 3 2 ## 3 3 3 3 2 ## 4 4 5 3 4 proportion_table &lt;- mutate(no_of_people_choose_A_4_Q1, A = A / no_of_respondents$n, B = B / no_of_respondents$n, C = C / no_of_respondents$n) print.data.frame(proportion_table) ## Q_NO A B C ## 1 1 0.8 0.4 0.6 ## 2 2 1.0 0.6 0.4 ## 3 3 0.6 0.6 0.4 ## 4 4 1.0 0.6 0.8 Note that the denominator should be 5 instead of 39. 2.2 Joining tables, be careful! When the values for one key variable are not unique, we must pay more attention to what we get from joining two tables – sometimes it’s not really what we want. Example 1: library(dplyr) (a_table &lt;- data_frame(x = letters[1:5], y = 1:5)) ## # A tibble: 5 x 2 ## x y ## &lt;chr&gt; &lt;int&gt; ## 1 a 1 ## 2 b 2 ## 3 c 3 ## 4 d 4 ## 5 e 5 (b_table &lt;- data_frame(x = c(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;))) ## # A tibble: 5 x 1 ## x ## &lt;chr&gt; ## 1 a ## 2 b ## 3 b ## 4 a ## 5 c Here we want to use x as the key and find “overlap” between a_table and b_table. We may write down (c_table &lt;- inner_join(a_table, b_table, by = &quot;x&quot;)) ## # A tibble: 5 x 2 ## x y ## &lt;chr&gt; &lt;int&gt; ## 1 a 1 ## 2 a 1 ## 3 b 2 ## 4 b 2 ## 5 c 3 but this code does not give the result that we want. so the correct code should be temp_b_table &lt;- b_table %&gt;% distinct(x) c_table &lt;- a_table %&gt;% inner_join(temp_b_table, by = &quot;x&quot;) (c_table) ## # A tibble: 3 x 2 ## x y ## &lt;chr&gt; &lt;int&gt; ## 1 a 1 ## 2 b 2 ## 3 c 3 Example 2: a_table &lt;- data_frame(x = letters[1:5], y = 1:5) d_table &lt;- data_frame(x = c(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;), z = 6:10) e_table &lt;- a_table %&gt;% left_join(d_table, by = &quot;x&quot;) (e_table) ## # A tibble: 7 x 3 ## x y z ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 a 1 6 ## 2 a 1 9 ## 3 b 2 7 ## 4 b 2 8 ## 5 c 3 10 ## 6 d 4 NA ## 7 e 5 NA Note that values of x in e_table are not unique and e_table has more rows than a_table. "],
["some-useful-tricks.html", "3 Some useful tricks 3.1 Removing rows under constraints 3.2 dplyr programming", " 3 Some useful tricks 3.1 Removing rows under constraints We discuss two cases. Case 1: removing rows that contain NA. For this case, we can use na.omit() or complete.cases(). Let us see the following example. Example: a_df &lt;- data_frame(x = c(&quot;a&quot;, NA, &quot;b&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;), y = c(runif(5), NA), z = c(LETTERS[1:3], NA, LETTERS[5:6])) (a_df) ## # A tibble: 6 x 3 ## x y z ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 a 0.214 A ## 2 &lt;NA&gt; 0.302 B ## 3 b 0.717 C ## 4 d 0.464 &lt;NA&gt; ## 5 e 0.460 E ## 6 f NA F # using na.omit to remove rows that have NA b_df &lt;- a_df %&gt;% na.omit() (b_df) ## # A tibble: 3 x 3 ## x y z ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 a 0.214 A ## 2 b 0.717 C ## 3 e 0.460 E # or using complete.cases c_df &lt;- a_df[complete.cases(a_df) == TRUE, ] (c_df) ## # A tibble: 3 x 3 ## x y z ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 a 0.214 A ## 2 b 0.717 C ## 3 e 0.460 E Case 2: removing rows contain some a specific symbol, e.g. “ZZZ”. Here the trick is to use rlang::sym. Example: library(dplyr) a_df &lt;- data_frame(x = c(&quot;a&quot;, &quot;ZZZ&quot;, &quot;b&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;), y = c(letters[1:5], &quot;ZZZ&quot;), z = c(LETTERS[1:3], &quot;ZZZ&quot;, LETTERS[5:6]), w = rnorm(6)) (a_df) ## # A tibble: 6 x 4 ## x y z w ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 a a A -1.04 ## 2 ZZZ b B -0.431 ## 3 b c C 1.03 ## 4 d d ZZZ -0.317 ## 5 e e E 0.565 ## 6 f ZZZ F 0.269 cols &lt;- colnames(a_df) b_df &lt;- a_df for(col in cols) {b_df &lt;- filter(b_df, (!!rlang::sym(col)) != &quot;ZZZ&quot;) } (b_df) ## # A tibble: 3 x 4 ## x y z w ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 a a A -1.04 ## 2 b c C 1.03 ## 3 e e E 0.565 NB: In the above, we must use parentheses around !!rlang::sym(col). 3.2 dplyr programming The good references are: https://cran.r-project.org/web/packages/dplyr/vignettes/programming.html https://edwinth.github.io/blog/dplyr-recipes/ Here, we try several examples. Example 1: square a variable in a dataframe, using rlang::sym() and !! (bang, bang) library(dplyr) sq_a_var &lt;- function(df, var) {new_var_name &lt;- paste0(var, &quot;_sq&quot;) new_df &lt;- df %&gt;% mutate(!!rlang::sym(new_var_name) := (!!rlang::sym(var))^2) new_df } a_df &lt;- data.frame(x = 1:3, y = 2:4) (sq_a_var(a_df, &quot;x&quot;)) ## x y x_sq ## 1 1 2 1 ## 2 2 3 4 ## 3 3 4 9 (sq_a_var(a_df, &quot;y&quot;)) ## x y y_sq ## 1 1 2 4 ## 2 2 3 9 ## 3 3 4 16 Version 2, in which we use dplyr::enquo() and dplyr::quo_name() and !! (bang, bang). library(dplyr) sq_a_var &lt;- function(df, var) {var_enquo &lt;- enquo(var) new_var_name &lt;- paste0(quo_name(var_enquo), &quot;_sq&quot;) new_df &lt;- df %&gt;% mutate(!!new_var_name := (!!var_enquo)^2) new_df } a_df &lt;- data.frame(x = 1:3, y = 2:4) (sq_a_var(a_df, x)) ## x y x_sq ## 1 1 2 1 ## 2 2 3 4 ## 3 3 4 9 (sq_a_var(a_df, y)) ## x y y_sq ## 1 1 2 4 ## 2 2 3 9 ## 3 3 4 16 Notice that in the above we use bare x or bare y rather than “x” or “y”. Example 2: find frequency of a variable, using enquo() and !! (bang, bang) library(dplyr) set.seed(20180425) a_df &lt;- data.frame(x = sample(letters[1:3], 6, replace = TRUE), y = sample(LETTERS[1:3], 6, replace = TRUE)) freq_table &lt;- function(df, var) {n &lt;- nrow(df) var_enqo &lt;- enquo(var) re &lt;- df %&gt;% group_by(!!var_enqo) %&gt;% summarise(freq = n() / n) re } (freq_table(a_df, x)) ## # A tibble: 3 x 2 ## x freq ## &lt;fct&gt; &lt;dbl&gt; ## 1 a 0.167 ## 2 b 0.167 ## 3 c 0.667 (freq_table(a_df, y)) ## # A tibble: 3 x 2 ## y freq ## &lt;fct&gt; &lt;dbl&gt; ## 1 A 0.167 ## 2 B 0.333 ## 3 C 0.500 Example 3: group-by more than a variable, using quos() and !!! library(dplyr) set.seed(20180425) a_df &lt;- data.frame(x = sample(letters[1:3], 6, replace = TRUE), y = sample(LETTERS[1:3], 6, replace = TRUE), z = as.character(rep(1:3, each = 2))) summ_a_few_vars &lt;- function(df, ...) {groupby_var &lt;- quos(...) re &lt;- df %&gt;% group_by(!!!groupby_var) %&gt;% summarise(freq = n()) re } (a_df) ## x y z ## 1 b B 1 ## 2 c B 1 ## 3 c C 2 ## 4 c C 2 ## 5 a A 3 ## 6 c C 3 (summ_a_few_vars(a_df, x, y)) ## # A tibble: 4 x 3 ## # Groups: x [?] ## x y freq ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 a A 1 ## 2 b B 1 ## 3 c B 1 ## 4 c C 3 (summ_a_few_vars(a_df, y, z)) ## # A tibble: 4 x 3 ## # Groups: y [?] ## y z freq ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 A 3 1 ## 2 B 1 2 ## 3 C 2 2 ## 4 C 3 1 Version 2, in which we use rlang::syms() and !!! library(dplyr) set.seed(20180425) a_df &lt;- data.frame(x = sample(letters[1:3], 6, replace = TRUE), y = sample(LETTERS[1:3], 6, replace = TRUE), z = as.character(rep(1:3, each = 2))) summ_a_few_vars &lt;- function(df, ...) {groupby_var &lt;- rlang::syms(...) re &lt;- df %&gt;% group_by(!!!groupby_var) %&gt;% summarise(freq = n()) re } (a_df) ## x y z ## 1 b B 1 ## 2 c B 1 ## 3 c C 2 ## 4 c C 2 ## 5 a A 3 ## 6 c C 3 (summ_a_few_vars(a_df, list(&quot;x&quot;, &quot;y&quot;))) ## # A tibble: 4 x 3 ## # Groups: x [?] ## x y freq ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 a A 1 ## 2 b B 1 ## 3 c B 1 ## 4 c C 3 (summ_a_few_vars(a_df, list(&quot;y&quot;, &quot;z&quot;))) ## # A tibble: 4 x 3 ## # Groups: y [?] ## y z freq ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 A 3 1 ## 2 B 1 2 ## 3 C 2 2 ## 4 C 3 1 "],
["tricking-plotting.html", "4 Tricking plotting 4.1 Bar charts", " 4 Tricking plotting 4.1 Bar charts We are going to create a bar chart. Here the requirements are: Bars are horizontal Bars are stacked In order, that is, the labels are in some order and the bars stacked in some order For each bar, put a number in the middle Using the colors provided by us rather than the default one library(dplyr) library(ggplot2) # utility functions ------------------------------------------------------- ## a helper function to find moving averages, which will be the positions for ## the counts my_mv_avg &lt;- function(x) {n &lt;- length(x) y &lt;- rep(0, n) y[1] &lt;- x[1] / 2 for(i in 2:n) y[i] &lt;- (x[i-1] + x[i]) / 2 y } ## self-defined scale_fill scale_fill_larry &lt;- function(...){ ggplot2:::manual_scale(&#39;fill&#39;, values = setNames(c(&quot;#77ec20&quot;, &quot;#ffc3a0&quot;, &quot;#20c3ff&quot;, &quot;#EA8E6C&quot;, &quot;#cc99cc&quot;, &quot;#fff68f&quot;, &quot;#66cdaa&quot;), c(&quot;apple&quot;, &quot;orange&quot;, &quot;kiwi fruit&quot;, &quot;banana&quot;, &quot;pear&quot;, &quot;plum&quot;, &quot;peach&quot;)), ...)} # data -------------------------------------------------------------------- ## prepare data fake_raw_data &lt;- data.frame(market = sample(c(&quot;Market 1&quot;, &quot;Market 2&quot;, &quot;Market 3&quot;), 1000, replace = TRUE), fruit = sample(c(&quot;apple&quot;, &quot;orange&quot;, &quot;kiwi fruit&quot;, &quot;banana&quot;, &quot;pear&quot;, &quot;plum&quot;, &quot;peach&quot;), 1000, replace = TRUE)) plotting_df &lt;- fake_raw_data %&gt;% group_by(market, fruit) %&gt;% tally() %&gt;% mutate(fruit = factor(fruit, levels = c(&quot;apple&quot;, &quot;orange&quot;, &quot;kiwi fruit&quot;, &quot;banana&quot;, &quot;pear&quot;, &quot;plum&quot;, &quot;peach&quot;))) %&gt;% ungroup() %&gt;% group_by(market) %&gt;% arrange(market, fruit) %&gt;% mutate(count_cum = cumsum(n)) %&gt;% mutate(plot_posi = my_mv_avg(count_cum)) # plotting ---------------------------------------------------------------- p &lt;- plotting_df %&gt;% # the order should be top-down or right-left # thus need to set the levels manually mutate(fruit = factor(fruit, levels = c(&quot;peach&quot;, &quot;plum&quot;, &quot;pear&quot;, &quot;banana&quot;, &quot;kiwi fruit&quot;, &quot;orange&quot;, &quot;apple&quot;))) %&gt;% ggplot(aes(x = market, y = n, fill = fruit)) + geom_bar(stat = &quot;identity&quot;, position = &quot;stack&quot;, width = 0.4) + geom_text(aes(x = market, y = plot_posi, label = scales::comma(n))) + labs(x = &quot;&quot;, y = &quot;(NB: The unit is ton)&quot;, title = &quot;A tricky bar chart&quot;) + # use specified colors to fill scale_fill_larry() + # horizontal bars coord_flip() + # put the labels in a specific order scale_x_discrete(limits = c(&quot;Market 3&quot;, &quot;Market 2&quot;, &quot;Market 1&quot;)) + theme(# axis.title.x = element_blank(), axis.text.x = element_blank(), axis.ticks.x = element_blank()) print(p) "]
]
