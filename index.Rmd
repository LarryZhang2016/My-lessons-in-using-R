--- 
title: "The lessons I learned in using R"
author: "Lingyun Zhang"
date: "2018-3-23"
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
link-citations: yes
links-as-notes: true
colorlinks: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<!-- # {-} -->


<!-- <!-- ![](pictures/rainbow.png) --> -->
<!-- <img src="pictures/office_buildings.png" style="width: 125%; height: 125%"/> -->


# Preface {-}

To be written. "Failures teach success."

# Small lessons

## Always use `na.rm = TRUE`

The following code is correct in terms of syntax, but it does not give the result that we expect.
```{r}
x <- c(1:3, NA, 4)
(y <- sum(x))
```

Instead, we should use
```{r}
x <- c(1:3, NA, 4)
(y <- sum(x, na.rm = TRUE))
```

## Always use `seq_along`

Sometime ago, I often write in my program something like 
```{r, eval=FALSE}
s <- 0
for(i in 1:length(x)) s <- s + 1
```
This piece of code may fail because the length of `x` may be 0. The safer and right way is to use `seq_along`. So, the code should be changed to
```{r, eval=FALSE}
s <- 0
for(i in seq_along(x)) s <- s + 1
```

## Always use `drop = FALSE`

Let's look at the following example:
```{r}
x <- diag(3)
y1 <- x[-1, ]
y2 <- x[-c(1, 2), ]
y3 <- x[-c(1, 2, 3), ]
(is.matrix(y1))
(is.matrix(y2))
(is.matrix(y3))
```
This is interesting, isn't? The above example shows a tiny bit of *inconsistency* in **R**; this inconsistency is dangerous
for programmers. To remove the inconsistency, we should change the code to
```{r}
x <- diag(3)
y1 <- x[-1, , drop = FALSE]
y2 <- x[-c(1, 2), , drop = FALSE]
y3 <- x[-c(1, 2, 3), , drop = FALSE]
(is.matrix(y1))
(is.matrix(y2))
(is.matrix(y3))
(y3)
```
Note that `y3` is a matrix of 0 rows and 3 columns. `y3` is not a real matrix in the mathematical sense but it is a legal
one in **R**.

## Always use `dir.create()`

I have the habit of creating folders by hand, but for writing programs that will be used by other people we should always do the following:

```{r, eval=FALSE, message=FALSE, warning=FALSE}
if(!dir.exists("./Folder-name")) dir.create("./Folder-name")
```



## Leap year problem

Suppose we want to get data from today back to three years ago from a database; we may write code like the following:
```{r, warning=FALSE, message=FALSE}
library(lubridate)
(query_start <- today() - years(3))
```
The code are OK most of time, but we will be in trouble if today is February 29, 2016. Let's see following code:
```{r, warning=FALSE, message=FALSE}
(query_start <- as.Date("2016-02-29") - years(3))
```
We got an `NA`; of course this is not what we wanted! We can write safer code as follows:
```{r, warning=FALSE, message=FALSE}
library(lubridate)
m_d <- substring(ymd(today()), 6, 10)
if(m_d == "02-29") {
  query_start <- today() + days(1) - years(3) - days(1)
} else { 
  query_start <- today() - years(3) }
(query_start)
```


## NA may cause troubles

We must be very cautious when we are dealing with NA's. The following code looked OK, but it 
does not give what we expect.
```{r, warning=FALSE, message=FALSE}
library(dplyr)

a_df <- data.frame(x = c(letters[1:5], rep(NA, 3)))

b_df <-
   a_df %>%
   filter(x != "c")
```
The right code should be
```{r}
library(dplyr)

a_df <- data.frame(x = c(letters[1:5], rep(NA, 3)))

b_df <-
   a_df %>%
   filter(x != "c" | is.na(x))
```
because we want to keep the rows where `x` is `NA`.

## using `tidyr::spread()`

I saw an example from https://www.r-bloggers.com/workaround-for-tidyrspread-with-duplicate-row-identifiers/, and I created a new example by tweaking the original one.

```{r}
library(tidyr)
library(dplyr)

long_table <- data.frame(age = sample(15:29, 5),
                         gender = sample(c("m", "f"), 5, replace = TRUE))
(long_table)

## this does not work

# wide_table <-
#   long_table %>%
#   spread(key = gender, value = age)

## this works
wide_table <-
  long_table %>%
  mutate(n = row_number()) %>%
  spread(key = gender, value = age) %>%
  select(-n) %>%
  arrange(f)

(wide_table)
```


 

 



# Big lessons

## Counting is not that easy

Finding number of rows under some constraints and then getting some a ratio is 
a common practice for an analyst who is doing official statistics. But sometimes counting is not that easy when **a record is not the same as a response**. An example is that people are allowed to make multiple choices. We use the following fake data to tell two stories.
```{r, warning=FALSE, message=FALSE}
library(readr)
the_url <- "https://raw.githubusercontent.com/LarryZhang2016/Data/master/fake_data_4_counting_example.csv"
fake_data <- read_csv(the_url)
print.data.frame(fake_data)
```

**Story 1:** Find the number of respondents.
The code below is **wrong**!
```{r, message = FALSE, warning=FALSE}
library(dplyr)
no_of_respondents <-
  fake_data %>% 
  summarise(n = n())

print.data.frame(no_of_respondents)
```
Here we should use `n_distinct()`, and the correct code is:
```{r, message = FALSE, warning=FALSE}
library(dplyr)
no_of_respondents <-
  fake_data %>% 
  summarise(n = n_distinct(ID))

print.data.frame(no_of_respondents)
```

**Story 2:** Tally the data with one dimension be Question-Number and the other dimension be Answers, and then create another table, which shows the proportions of people made the choice. 
```{r, message = FALSE, warning=FALSE}
no_of_people_choose_A_4_Q1 <-
  fake_data %>% 
  group_by(Q_NO, answers) %>% 
  tally() %>% 
  tidyr::spread(key = answers, value = n)

print.data.frame(no_of_people_choose_A_4_Q1)

proportion_table <- 
  mutate(no_of_people_choose_A_4_Q1, 
         A = A / no_of_respondents$n,
         B = B / no_of_respondents$n,
         C = C / no_of_respondents$n) 

print.data.frame(proportion_table)
```
Note that the denominator should be **5** instead of **39**.

## Joining tables, be careful! 

When the values for one key variable are not unique, we must pay more attention to what we get from joining two tables -- sometimes it's not really what we want.

**Example 1:**
```{r, warning=FALSE, message=FALSE}
library(dplyr)

(a_table <- data_frame(x = letters[1:5], y = 1:5))
(b_table <- data_frame(x = c("a", "b", "b", "a", "c")))
```
Here we want to use `x` as the key and find "overlap" between `a_table` and `b_table`. We may write down 
```{r, warning=FALSE, message=FALSE}
(c_table <- inner_join(a_table, b_table, by = "x"))
```
but this code does not give the result that we want. so the correct code should be
```{r, warning=FALSE, message=FALSE}
temp_b_table <-
  b_table %>% 
  distinct(x)
  
c_table <-
  a_table %>% 
  inner_join(temp_b_table, by = "x")

(c_table)
```

**Example 2:**
```{r, warning=FALSE, message=FALSE}
a_table <- data_frame(x = letters[1:5], y = 1:5)
d_table <- data_frame(x = c("a", "b", "b", "a", "c"), 
                      z = 6:10)

e_table <-
  a_table %>% 
  left_join(d_table, by = "x") 
(e_table)
```
Note that values of `x` in `e_table` are not unique and `e_table` has more rows than `a_table`.


# Some useful tricks

## Removing rows under constraints

We discuss two cases. 

**Case 1**: removing rows that contain NA. For this case, we can use `na.omit()` or  `complete.cases()`. Let us see the following example.

**Example:**
```{r, warning=FALSE, message=FALSE}
a_df <- 
  data_frame(x = c("a", NA, "b", "d", "e", "f"),
             y = c(runif(5), NA),
             z = c(LETTERS[1:3], NA, LETTERS[5:6]))
(a_df)

# using na.omit to remove rows that have NA
b_df <- 
  a_df %>% 
  na.omit()
(b_df)

# or using complete.cases
c_df <- 
  a_df[complete.cases(a_df) == TRUE, ] 
(c_df)
```

**Case 2**: removing rows contain some a specific symbol, e.g. "ZZZ". Here the trick is to use `rlang::sym`.

**Example:**
```{r, message=FALSE, warning=FALSE}
library(dplyr)
a_df <- 
  data_frame(x = c("a", "ZZZ", "b", "d", "e", "f"),
             y = c(letters[1:5], "ZZZ"),
             z = c(LETTERS[1:3], "ZZZ", LETTERS[5:6]),
             w = rnorm(6))
(a_df)

cols <- colnames(a_df)
b_df <- a_df
for(col in cols)
{b_df <-
  filter(b_df, (!!rlang::sym(col)) != "ZZZ")
}
(b_df)
```

**NB**: In the above, we must use parentheses around `!!rlang::sym(col).`

## dplyr programming

The good references are:

- https://cran.r-project.org/web/packages/dplyr/vignettes/programming.html
- https://edwinth.github.io/blog/dplyr-recipes/

Here, we try several examples.

**Example 1: square a variable in a dataframe, using `rlang::sym()` and `!!` (bang, bang)**
```{r, message=FALSE, warning=FALSE}
library(dplyr)

sq_a_var <- function(df, var)
{new_var_name <- paste0(var, "_sq")

 new_df <-
  df %>%
  mutate(!!rlang::sym(new_var_name) := (!!rlang::sym(var))^2)

 new_df
}

a_df <- data.frame(x = 1:3,
                   y = 2:4)

(sq_a_var(a_df, "x"))
(sq_a_var(a_df, "y"))
```

**Version 2**, in which we use `dplyr::enquo()` and `dplyr::quo_name()` and `!!` (bang, bang).
```{r, message=FALSE, warning=FALSE}
library(dplyr)

sq_a_var <- function(df, var)
{var_enquo <- enquo(var)
  
 new_var_name <- paste0(quo_name(var_enquo), "_sq")

 new_df <-
  df %>%
  mutate(!!new_var_name := (!!var_enquo)^2)

 new_df
}

a_df <- data.frame(x = 1:3,
                   y = 2:4)

(sq_a_var(a_df, x))
(sq_a_var(a_df, y))
```
**Notice that in the above we use bare x or bare y rather than "x" or "y".**


**Example 2: find frequency of a variable, using `enquo()` and `!!` (bang, bang)**
```{r, warning=FALSE, message=FALSE}
library(dplyr)

set.seed(20180425)
a_df <- data.frame(x = sample(letters[1:3], 6, replace = TRUE),
                   y = sample(LETTERS[1:3], 6, replace = TRUE))

freq_table <- function(df, var)
{n <- nrow(df)

 var_enqo <- enquo(var)
 
 re <- 
   df %>% 
   group_by(!!var_enqo) %>% 
   summarise(freq = n() / n)
 
 re
}

(freq_table(a_df, x))
(freq_table(a_df, y))
```

**Example 3: group-by more than a variable, using `quos()` and `!!!`**
```{r, message=FALSE, warning=FALSE}
library(dplyr)

set.seed(20180425)
a_df <- data.frame(x = sample(letters[1:3], 6, replace = TRUE),
                   y = sample(LETTERS[1:3], 6, replace = TRUE),
                   z = as.character(rep(1:3, each = 2)))

summ_a_few_vars <- function(df, ...)
{groupby_var <- quos(...)

 re <- 
   df %>% 
   group_by(!!!groupby_var) %>% 
   summarise(freq = n())
 
 re
}
(a_df)
(summ_a_few_vars(a_df, x, y))
(summ_a_few_vars(a_df, y, z))

```

**Version 2**, in which we use `rlang::syms()` and `!!!`
```{r, message=FALSE, warning=FALSE}
library(dplyr)

set.seed(20180425)
a_df <- data.frame(x = sample(letters[1:3], 6, replace = TRUE),
                   y = sample(LETTERS[1:3], 6, replace = TRUE),
                   z = as.character(rep(1:3, each = 2)))

summ_a_few_vars <- function(df, ...)
{groupby_var <- rlang::syms(...)

re <- 
  df %>% 
  group_by(!!!groupby_var) %>% 
  summarise(freq = n())

re
}

(a_df)
(summ_a_few_vars(a_df, list("x", "y")))
(summ_a_few_vars(a_df, list("y", "z")))

```
